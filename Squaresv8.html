<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="google-site-verification" content="ca-pub-2837173229911395" />
  <meta charset="UTF-8" />
  <title>Square Game - CPU Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
  <style>
    body { background-color: #2b2b2b; }
    .grid-board-container, .instructions-box { background-color: #1a1a1a; }
    .last-move {
      position: relative;
    }
    .last-move::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 150%;
      height: 150%;
      background: none;
      border: 8px solid rgba(192, 192, 192, 0.9);
      border-radius: 50%;
      box-shadow: 0 0 20px 8px rgba(192, 192, 192, 0.8);
      transform: translate(-50%, -50%);
      opacity: 1;
      animation: fadeOutRing 3s forwards;
      pointer-events: none;
      z-index: 5;
    }
    @keyframes fadeOutRing {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    .dot {
      position: absolute;
      width: clamp(14px, 3.8vmin, 30px);
      height: clamp(14px, 3.8vmin, 30px);
      max-width: 30px;
      max-height: 30px;
      border-radius: 50%;
      background-color: white;
      transform: translate(-50%, -50%);
      cursor: pointer;
      z-index: 2;
      box-shadow: inset -6px -6px 12px rgba(0, 0, 0, 0.7), inset 6px 6px 12px rgba(255, 255, 255, 0.3);
      transition: all 0.18s ease-in-out;
    }
    .dot:hover {
      box-shadow: inset -6px -6px 14px rgba(0, 0, 0, 0.7),
                  inset 6px 6px 14px rgba(255, 255, 255, 0.3),
                  0 0 8px rgba(255, 255, 255, 0.5),
                  0 0 12px rgba(255, 255, 255, 0.4);
      transition: all 0.3s ease;
    }
    .dot:active {
      box-shadow: inset -8px -8px 16px rgba(0, 0, 0, 0.7), inset 8px 8px 16px rgba(255, 255, 255, 0.3), 0 0 10px rgba(255, 255, 255, 0.6);
    }
    .dot.player1 {
      background: linear-gradient(145deg, #007BFF, #00BFFF);
    }
    .dot.player2 {
      background: linear-gradient(145deg, #FF0000, #FF6347);
    }
    .line {
      position: absolute;
      transform-origin: left center;
      z-index: 1;
    }
    .line.player1 { background-color: rgba(59, 130, 246, 0.5); }
    .line.player2 { background-color: rgba(239, 68, 68, 0.5); }
    .active {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
      transform: scale(1.05);
    }
    .grid-board-container {
      position: relative;
      width: min(92vw, 68vh);
      height: min(92vw, 68vh);
      max-width: 720px;
      max-height: 720px;
      overflow: hidden;
      box-sizing: border-box;
    }
    .grid-container { position: relative; }
    .mode-buttons { margin-bottom: 20px; }
    .mode-button {
      background: linear-gradient(145deg, #1e3c72, #2a5298);
      color: white;
      padding: 10px 20px;
      margin: 0 10px;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid #eee;
      font-size: 16px;
      transition: all 0.3s ease;
      filter: brightness(50%);
    }
    .mode-button.cpu {
      background: linear-gradient(145deg, #8b0000, #ff0000);
    }
    .mode-button.online {
      background: linear-gradient(145deg, #065f46, #10b981);
    }
    .mode-button.active {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
      transform: scale(1.05);
      filter: brightness(100%);
    }
    /* Dim non-active player cards */
    .player-card {
      filter: brightness(50%);
      transition: filter 0.3s ease;
      width: min(192px, 31vw);
      min-width: 120px;
    }
    .player-card.active {
      filter: brightness(100%);
      transform: none;
    }
    @media (max-width: 640px), (max-height: 760px) {
      .grid-board-container {
        width: min(94vw, 56vh);
        height: min(94vw, 56vh);
        padding: 0.75rem;
      }
      .player-card {
        width: min(172px, 44vw);
      }
    }

    /* Popup overlay and animation */
    #popupMessage {
      background-color: rgba(0, 0, 0, 0.5); /* semi-transparent overlay */
      transition: opacity 0.5s ease;
      opacity: 0;
    }
    #popupMessage.show {
      opacity: 1;
    }
  </style>
  <!-- AdSense Global Site Tag -->
  <script async
          src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2837173229911395"
          crossorigin="anonymous"></script>
</head>
<body>
  <div class="flex justify-center mode-buttons">
    <button id="pvpMode" class="mode-button active">Player vs Player</button>
    <button id="cpuMode" class="mode-button cpu">Player vs CPU</button>
    <button id="onlineMode" class="mode-button online">Online</button>
  </div>
  <div id="onlineControls" class="hidden flex flex-col items-center text-white mt-2">
    <div class="flex flex-wrap justify-center gap-2">
      <button id="createRoomButton" class="mode-button online">Create Room</button>
      <input id="roomCodeInput" class="text-black rounded px-3 py-2 w-36" type="text" maxlength="6" placeholder="Room Code" />
      <button id="joinRoomButton" class="mode-button online">Join Room</button>
      <button id="leaveRoomButton" class="mode-button">Leave Room</button>
    </div>
    <p id="onlineStatus" class="mt-2 text-sm text-gray-300">Online mode is off.</p>
    <p id="onlineShareCode" class="mt-1 text-sm font-semibold text-emerald-300"></p>
  </div>
  <div id="difficultyButtons" class="hidden flex justify-center mt-2">
    <button id="difficultyEasy" data-value="easy" class="mode-button ml-4" style="background: linear-gradient(145deg, #007BFF, #00BFFF);">Easy</button>
    <button id="difficultyMedium" data-value="medium" class="mode-button ml-4 active" style="background: linear-gradient(145deg, #007BFF, #FF0000);">Medium</button>
    <button id="difficultyHard" data-value="hard" class="mode-button ml-4" style="background: linear-gradient(145deg, #FF0000, #FF6347);">Hard</button>
  </div>
  <div id="pvpSettings" class="hidden flex justify-center mt-2">
    <label class="text-white ml-4">
      <input type="checkbox" id="alternateStart" class="mr-2"/>
      Alternate Starting Player
    </label>
  </div>
  <div class="flex flex-col items-center">
    <div class="flex flex-wrap justify-center gap-3 mb-8 w-full max-w-3xl px-3">
      <div id="player1Card" class="player-card bg-gradient-to-br from-blue-500 to-blue-700 p-4 text-white text-center active">
        <h2 class="text-xl font-bold">Player 1</h2>
        <p class="text-3xl font-bold mt-2" id="player1Score">0</p>
        <div id="player1Timer" class="turn-timer text-white mt-2 hidden">Turn time: 00:00</div>
      </div>
      <div class="player-card active bg-white bg-opacity-10 rounded-lg p-3 text-white text-center">
        <p id="gameStatus" class="font-medium">Player 1's Turn</p>
        <button id="resetButton" class="mt-2 bg-white text-gray-800 px-4 py-1 rounded-full font-medium hover:bg-gray-100 transition">Reset Game</button>
      </div>
      <div id="player2Card" class="player-card bg-gradient-to-br from-red-500 to-red-700 p-4 text-white text-center">
        <h2 class="text-xl font-bold">Player 2</h2>
        <p class="text-3xl font-bold mt-2" id="player2Score">0</p>
        <div id="player2Timer" class="turn-timer text-white mt-2 hidden">Turn time: 00:00</div>
      </div>
    </div>
  </div>
  <div class="flex justify-center mb-6">
    <div class="bg-black bg-opacity-20 rounded-lg p-6 grid-board-container">
      <div id="gridContainer" class="grid-container"></div>
    </div>
  </div>
  <!-- AdSense Ad Unit -->
  <div class="ad-slot" style="margin: 20px auto; text-align: center;">
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-2837173229911395"
         data-ad-slot="YYYYYYYYYY"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </div>
  <div class="text-white text-center bg-black bg-opacity-20 p-4 rounded-lg instructions-box w-5/6 mx-auto">
    <h3 class="font-bold mb-2">How to Play</h3>
    <p>Players take turns selecting dots. When a player's selections form a square of any size, they earn points based on the square size.</p>
    <p class="mt-2"><span class="font-bold">Scoring:</span> 1×1 square = 1 point, 2×2 square = 4 points, 3×3 square = 9 points, etc.</p>
    <p class="mt-2"><span class="font-bold">Game End:</span> The game ends when all dots are selected.</p>
  </div>
<!-- Popup message for end of round -->
<div id="popupMessage" class="fixed inset-0 flex items-center justify-center hidden z-50">
  <div class="rounded-lg p-6 text-center text-white transform transition-transform duration-500 scale-0"
    style="background: linear-gradient(145deg, #FF0000, #007BFF); box-shadow: 0 0 40px rgba(255, 255, 255, 0.5);">
    <p class="text-white text-xl font-bold mb-4">Play Again</p>
    <button id="popupButton" class="bg-black text-white px-4 py-2 rounded">OK</button>
  </div>
</div>
<script>
const gridSize = 8;
let spacing = 80;
const lineThickness = 6;
const totalDots = gridSize * gridSize;
let currentPlayer = 1;
let scores = [0, 0];
let selectedDots = [];
let lines = [];
let lineSegments = [];
let selectedDotCount = 0;
let mode = "pvp";
let turnStartTime = Date.now();
let timerInterval;
let difficulty = "medium";
let alternateStart = false;
let lastStartingPlayer = 2;
let onlineReady = false;
let onlinePlayerNumber = null;

// Set window.SQUARE_GAME_FIREBASE_CONFIG = { ... } before this script to enable online rooms.
const FIREBASE_CONFIG = window.SQUARE_GAME_FIREBASE_CONFIG || null;
const ONLINE_DB_PATH = "squareGameRooms";
const localClientId = Math.random().toString(36).slice(2, 10);
let db = null;
const onlineSession = {
  roomId: null,
  unsubscribe: null,
  isApplyingRemote: false,
  lastStateHash: ""
};

const gridContainer = document.getElementById('gridContainer');
const boardContainer = document.querySelector('.grid-board-container');
const player1Score = document.getElementById('player1Score');
const player2Score = document.getElementById('player2Score');
const player1Card = document.getElementById('player1Card');
const player2Card = document.getElementById('player2Card');
const gameStatus = document.getElementById('gameStatus');
const resetButton = document.getElementById('resetButton');
const player1Timer = document.getElementById('player1Timer');
const player2Timer = document.getElementById('player2Timer');
const pvpMode = document.getElementById('pvpMode');
const cpuMode = document.getElementById('cpuMode');
const onlineMode = document.getElementById('onlineMode');
const pvpSettings = document.getElementById('pvpSettings');
const alternateStartCheckbox = document.getElementById('alternateStart');
const difficultyButtons = document.getElementById('difficultyButtons');
const difficultyEasy = document.getElementById('difficultyEasy');
const difficultyMedium = document.getElementById('difficultyMedium');
const difficultyHard = document.getElementById('difficultyHard');
const onlineControls = document.getElementById('onlineControls');
const createRoomButton = document.getElementById('createRoomButton');
const joinRoomButton = document.getElementById('joinRoomButton');
const leaveRoomButton = document.getElementById('leaveRoomButton');
const roomCodeInput = document.getElementById('roomCodeInput');
const onlineStatus = document.getElementById('onlineStatus');
const onlineShareCode = document.getElementById('onlineShareCode');

if (alternateStartCheckbox) {
  alternateStartCheckbox.addEventListener('change', () => {
    alternateStart = alternateStartCheckbox.checked;
  });
}

function setOnlineStatus(message) {
  if (onlineStatus) onlineStatus.textContent = message;
}

function showEndPopup() {
  const popupMessage = document.getElementById('popupMessage');
  if (!popupMessage) return;
  popupMessage.classList.remove('hidden');
  setTimeout(() => {
    popupMessage.classList.add('show');
    const popupInner = popupMessage.querySelector('div');
    if (popupInner) {
      popupInner.classList.remove('scale-0');
      popupInner.classList.add('scale-100');
    }
  }, 10);
}

function hideEndPopup() {
  const popupMessage = document.getElementById('popupMessage');
  if (!popupMessage) return;
  popupMessage.classList.remove('show');
  const popupInner = popupMessage.querySelector('div');
  if (popupInner) {
    popupInner.classList.remove('scale-100');
    popupInner.classList.add('scale-0');
  }
  popupMessage.classList.add('hidden');
}

function initializeOnlineBackend() {
  if (!FIREBASE_CONFIG || !window.firebase) return false;
  try {
    if (!firebase.apps.length) {
      firebase.initializeApp(FIREBASE_CONFIG);
    }
    db = firebase.database();
    return true;
  } catch (error) {
    console.error("Failed to initialize Firebase:", error);
    return false;
  }
}

function getResponsiveBoardSize() {
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const boardTop = boardContainer.getBoundingClientRect().top;
  const verticalRoom = viewportHeight - boardTop - 16;
  const horizontalRoom = viewportWidth - 24;
  const usable = Math.min(720, horizontalRoom, verticalRoom);
  return Math.max(220, Math.floor(usable));
}

function createGrid(options = {}) {
  const preserveState = Boolean(options.preserveState);
  gridContainer.innerHTML = '';

  if (!preserveState) {
    selectedDots = [];
    lines = [];
    lineSegments = [];
    selectedDotCount = 0;
    scores = [0, 0];
    player1Score.textContent = "0";
    player2Score.textContent = "0";
    if (mode === "pvp" && alternateStart) {
      currentPlayer = (lastStartingPlayer === 1) ? 2 : 1;
      lastStartingPlayer = currentPlayer;
    } else {
      currentPlayer = 1;
    }
  }

  const boardSize = getResponsiveBoardSize();
  boardContainer.style.width = `${boardSize}px`;
  boardContainer.style.height = `${boardSize}px`;

  const boardStyles = window.getComputedStyle(boardContainer);
  const horizontalPadding = parseFloat(boardStyles.paddingLeft) + parseFloat(boardStyles.paddingRight);
  const innerBoardSize = Math.max(160, boardSize - horizontalPadding);
  spacing = innerBoardSize / (gridSize - 1);

  gridContainer.style.width = `${innerBoardSize}px`;
  gridContainer.style.height = `${innerBoardSize}px`;

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.left = `${x * spacing}px`;
      dot.style.top = `${y * spacing}px`;
      dot.dataset.x = x;
      dot.dataset.y = y;
      dot.dataset.id = `${x}-${y}`;
      dot.addEventListener('click', () => handleDotClick(dot));
      gridContainer.appendChild(dot);
    }
  }

  if (preserveState) {
    renderPersistedState();
  }
  updatePlayerTurn();
}

function renderPersistedState() {
  const claimedMap = new Map(selectedDots.map(dot => [dot.id, dot.player]));
  gridContainer.querySelectorAll('.dot').forEach(dotEl => {
    const player = claimedMap.get(dotEl.dataset.id);
    if (player) {
      dotEl.classList.add(`player${player}`);
    }
  });
  lineSegments.forEach(segment => {
    drawLine(
      { x: segment.x1, y: segment.y1 },
      { x: segment.x2, y: segment.y2 },
      segment.player,
      false
    );
  });
  player1Score.textContent = String(scores[0] || 0);
  player2Score.textContent = String(scores[1] || 0);
}

function handleDotClick(dotEl) {
  if (dotEl.classList.contains('player1') || dotEl.classList.contains('player2')) return;
  if (mode === "cpu" && currentPlayer !== 1) return;
  if (mode === "online") {
    if (!onlineSession.roomId) {
      setOnlineStatus("Create or join an online room first.");
      return;
    }
    if (!onlinePlayerNumber) {
      setOnlineStatus("You are not in this room as a player.");
      return;
    }
    if (currentPlayer !== onlinePlayerNumber) return;
  }

  const actingPlayer = currentPlayer;
  applyMove(dotEl, actingPlayer, true);

  if (mode === "online" && onlineSession.roomId) {
    void publishOnlineState();
    return;
  }

  if (mode === "cpu" && currentPlayer === 2 && selectedDotCount < totalDots) {
    const delay = difficulty === "easy" ? 1200 : difficulty === "medium" ? 800 : 500;
    setTimeout(cpuMove, delay);
  }
}

function applyMove(dotEl, player, highlightLastMove) {
  dotEl.classList.add(`player${player}`);
  if (highlightLastMove) {
    clearLastMoveHighlight();
    dotEl.classList.add('last-move');
    setTimeout(() => {
      dotEl.classList.remove('last-move');
    }, 2000);
  }

  selectedDotCount++;
  selectedDots.push({
    x: parseInt(dotEl.dataset.x, 10),
    y: parseInt(dotEl.dataset.y, 10),
    id: dotEl.dataset.id,
    player
  });
  checkForSquares(player);

  if (selectedDotCount === totalDots) {
    showEndPopup();
    return;
  }

  currentPlayer = player === 1 ? 2 : 1;
  updatePlayerTurn();
  resetTurnTimer();
}

function wouldMakeSquare(x, y, player) {
  const dots = selectedDots
    .filter(d => d.player === player)
    .map(d => ({ x: d.x, y: d.y, id: d.id }));
  dots.push({ x, y, id: `${x}-${y}` });
  for (let i = 0; i < dots.length; i++) {
    for (let j = i + 1; j < dots.length; j++) {
      for (let k = j + 1; k < dots.length; k++) {
        for (let l = k + 1; l < dots.length; l++) {
          const quad = [dots[i], dots[j], dots[k], dots[l]];
          if (isSquare(quad) && quad.some(d => d.x === x && d.y === y)) {
            return true;
          }
        }
      }
    }
  }
  return false;
}

function cpuMove() {
  if (mode !== "cpu") return;
  const availableDots = [...document.querySelectorAll('.dot:not(.player1):not(.player2)')];
  if (availableDots.length === 0) return;

  let chosenDot;
  if (difficulty === "easy") {
    chosenDot = availableDots[Math.floor(Math.random() * availableDots.length)];
  } else if (difficulty === "medium") {
    let blockDot = null;
    for (const dot of availableDots) {
      const x = parseInt(dot.dataset.x, 10);
      const y = parseInt(dot.dataset.y, 10);
      if (wouldMakeSquare(x, y, 1)) {
        blockDot = dot;
        break;
      }
    }
    chosenDot = blockDot || availableDots[Math.floor(Math.random() * availableDots.length)];
  } else {
    let winDot = null;
    for (const dot of availableDots) {
      const x = parseInt(dot.dataset.x, 10);
      const y = parseInt(dot.dataset.y, 10);
      if (wouldMakeSquare(x, y, 2)) {
        winDot = dot;
        break;
      }
    }
    if (winDot) {
      chosenDot = winDot;
    } else {
      let blockDot = null;
      for (const dot of availableDots) {
        const x = parseInt(dot.dataset.x, 10);
        const y = parseInt(dot.dataset.y, 10);
        if (wouldMakeSquare(x, y, 1)) {
          blockDot = dot;
          break;
        }
      }
      chosenDot = blockDot || availableDots[Math.floor(Math.random() * availableDots.length)];
    }
  }

  applyMove(chosenDot, 2, true);
}

function clearLastMoveHighlight() {
  document.querySelectorAll('.last-move').forEach(dot => dot.classList.remove('last-move'));
}

function checkForSquares(player) {
  const playerDots = selectedDots.filter(dot => dot.player === player);
  if (playerDots.length < 4) return;

  for (let i = 0; i < playerDots.length; i++) {
    for (let j = i + 1; j < playerDots.length; j++) {
      for (let k = j + 1; k < playerDots.length; k++) {
        for (let l = k + 1; l < playerDots.length; l++) {
          const dots = [playerDots[i], playerDots[j], playerDots[k], playerDots[l]];
          if (isSquare(dots)) {
            const squareKey = dots.map(d => d.id).sort().join(',');
            if (!lines.includes(squareKey)) {
              lines.push(squareKey);
              const sideLength = Math.sqrt((dots[0].x - dots[1].x) ** 2 + (dots[0].y - dots[1].y) ** 2);
              const points = Math.round(sideLength * sideLength);
              scores[player - 1] += points;
              player1Score.textContent = String(scores[0]);
              player2Score.textContent = String(scores[1]);
              drawSquare(dots, player);
            }
          }
        }
      }
    }
  }
}

function isSquare(dots) {
  const [a, b, c, d] = dots;
  const dist = (p1, p2) => Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
  const dists = [
    dist(a, b), dist(a, c), dist(a, d),
    dist(b, c), dist(b, d), dist(c, d)
  ].sort((x, y) => x - y);
  return dists[0] > 0 &&
         dists[0] === dists[1] &&
         dists[1] === dists[2] &&
         dists[2] === dists[3] &&
         dists[4] === dists[5] &&
         dists[4] === 2 * dists[0];
}

function drawSquare(dots, player) {
  const sortedDots = sortDotsInOrder(dots);
  for (let i = 0; i < sortedDots.length; i++) {
    const dot1 = sortedDots[i];
    const dot2 = sortedDots[(i + 1) % sortedDots.length];
    drawLine(dot1, dot2, player, true);
  }
}

function sortDotsInOrder(dots) {
  const centerX = dots.reduce((sum, dot) => sum + dot.x, 0) / dots.length;
  const centerY = dots.reduce((sum, dot) => sum + dot.y, 0) / dots.length;
  return [...dots].sort((a, b) => {
    const angleA = Math.atan2(a.y - centerY, a.x - centerX);
    const angleB = Math.atan2(b.y - centerY, b.x - centerX);
    return angleA - angleB;
  });
}

function drawLine(dot1, dot2, player = currentPlayer, recordSegment = true) {
  const x1 = dot1.x * spacing;
  const y1 = dot1.y * spacing;
  const x2 = dot2.x * spacing;
  const y2 = dot2.y * spacing;
  const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
  const line = document.createElement('div');
  line.className = `line player${player}`;
  line.style.width = `${length}px`;
  line.style.height = `${lineThickness}px`;
  line.style.left = `${x1}px`;
  line.style.top = `${y1}px`;
  line.style.transform = `rotate(${angle}deg)`;
  gridContainer.appendChild(line);

  if (recordSegment) {
    lineSegments.push({
      x1: dot1.x, y1: dot1.y,
      x2: dot2.x, y2: dot2.y,
      player
    });
  }
}

function startTurnTimer() {
  turnStartTime = Date.now();
  updateTimerDisplay();
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(updateTimerDisplay, 1000);
}

function resetTurnTimer() {
  turnStartTime = Date.now();
  updateTimerDisplay();
}

function updateTimerDisplay() {
  const elapsedTime = Date.now() - turnStartTime;
  const seconds = Math.floor((elapsedTime / 1000) % 60);
  const minutes = Math.floor((elapsedTime / (1000 * 60)) % 60);
  const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  player1Timer.classList.add('hidden');
  player2Timer.classList.add('hidden');
  if (currentPlayer === 1) {
    player1Timer.textContent = formattedTime;
    player1Timer.classList.remove('hidden');
  } else {
    player2Timer.textContent = formattedTime;
    player2Timer.classList.remove('hidden');
  }
}

function updatePlayerTurn() {
  player1Card.classList.toggle('active', currentPlayer === 1);
  player2Card.classList.toggle('active', currentPlayer === 2);
  if (mode === "online" && onlineSession.roomId) {
    gameStatus.textContent = `Room ${onlineSession.roomId} • Player ${currentPlayer}'s Turn`;
  } else if (mode === "online") {
    gameStatus.textContent = "Create or Join an Online Room";
  } else {
    gameStatus.textContent = `Player ${currentPlayer}'s Turn`;
  }
}

function getStateHash(state) {
  return JSON.stringify({
    selectedDots: state.selectedDots,
    scores: state.scores,
    currentPlayer: state.currentPlayer,
    selectedDotCount: state.selectedDotCount,
    lines: state.lines
  });
}

function serializeGameState() {
  return {
    selectedDots: selectedDots.map(dot => ({ ...dot })),
    lines: [...lines],
    lineSegments: lineSegments.map(segment => ({ ...segment })),
    scores: [...scores],
    currentPlayer,
    selectedDotCount
  };
}

function applyOnlineState(state) {
  if (!state) return;
  const nextHash = getStateHash(state);
  if (nextHash === onlineSession.lastStateHash) return;

  onlineSession.isApplyingRemote = true;
  selectedDots = Array.isArray(state.selectedDots) ? state.selectedDots.map(dot => ({ ...dot })) : [];
  lines = Array.isArray(state.lines) ? [...state.lines] : [];
  lineSegments = Array.isArray(state.lineSegments) ? state.lineSegments.map(segment => ({ ...segment })) : [];
  scores = Array.isArray(state.scores) ? [...state.scores] : [0, 0];
  currentPlayer = state.currentPlayer === 2 ? 2 : 1;
  selectedDotCount = Number.isFinite(state.selectedDotCount) ? state.selectedDotCount : selectedDots.length;

  createGrid({ preserveState: true });
  if (selectedDotCount === totalDots) {
    showEndPopup();
  } else {
    hideEndPopup();
  }
  onlineSession.lastStateHash = nextHash;
  onlineSession.isApplyingRemote = false;
}

async function publishOnlineState() {
  if (!onlineReady || !onlineSession.roomId || onlineSession.isApplyingRemote) return;
  const roomRef = db.ref(`${ONLINE_DB_PATH}/${onlineSession.roomId}`);
  const state = serializeGameState();
  onlineSession.lastStateHash = getStateHash(state);
  try {
    await roomRef.update({
      state,
      updatedAt: Date.now()
    });
  } catch (error) {
    setOnlineStatus("Failed to sync move. Check connection.");
    console.error(error);
  }
}

function generateRoomCode() {
  return Math.random().toString(36).slice(2, 8).toUpperCase();
}

function subscribeToRoom(roomId) {
  if (!onlineReady) return;
  const roomRef = db.ref(`${ONLINE_DB_PATH}/${roomId}`);
  if (onlineSession.unsubscribe && onlineSession.roomId) {
    const previousRef = db.ref(`${ONLINE_DB_PATH}/${onlineSession.roomId}`);
    previousRef.off('value', onlineSession.unsubscribe);
  }

  const handler = snapshot => {
    if (!snapshot.exists()) {
      setOnlineStatus("Room closed.");
      onlineSession.roomId = null;
      onlinePlayerNumber = null;
      onlineShareCode.textContent = "";
      updatePlayerTurn();
      return;
    }

    const room = snapshot.val();
    if (room.hostId === localClientId) {
      onlinePlayerNumber = 1;
    } else if (room.guestId === localClientId) {
      onlinePlayerNumber = 2;
    } else {
      onlinePlayerNumber = null;
    }

    if (room.state) {
      applyOnlineState(room.state);
    }

    const waitingText = room.guestId ? "" : " Waiting for Player 2.";
    const roleText = onlinePlayerNumber ? `You are Player ${onlinePlayerNumber}.` : "Spectating.";
    const turnText = room.state ? ` Player ${room.state.currentPlayer}'s turn.` : "";
    setOnlineStatus(`${roleText}${waitingText}${turnText}`);
  };

  roomRef.on('value', handler);
  onlineSession.unsubscribe = handler;
  onlineSession.roomId = roomId;
}

async function createOnlineRoom() {
  if (!onlineReady) {
    setOnlineStatus("Online mode is unavailable. Add Firebase config.");
    return;
  }

  await leaveOnlineRoom(false);
  hideEndPopup();
  createGrid();
  startTurnTimer();

  let roomId = null;
  for (let attempt = 0; attempt < 5; attempt++) {
    const candidate = generateRoomCode();
    const roomRef = db.ref(`${ONLINE_DB_PATH}/${candidate}`);
    const initialState = serializeGameState();
    const result = await roomRef.transaction(current => {
      if (current) return;
      return {
        hostId: localClientId,
        guestId: null,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        state: initialState
      };
    });
    if (result.committed) {
      roomId = candidate;
      break;
    }
  }

  if (!roomId) {
    setOnlineStatus("Could not create a room. Try again.");
    return;
  }

  onlinePlayerNumber = 1;
  subscribeToRoom(roomId);
  onlineShareCode.textContent = `Share code: ${roomId}`;
  setOnlineStatus("Room created. Waiting for Player 2.");
}

async function joinOnlineRoom() {
  if (!onlineReady) {
    setOnlineStatus("Online mode is unavailable. Add Firebase config.");
    return;
  }

  const roomId = (roomCodeInput.value || "").trim().toUpperCase();
  if (!roomId) {
    setOnlineStatus("Enter a room code.");
    return;
  }

  await leaveOnlineRoom(false);
  const roomRef = db.ref(`${ONLINE_DB_PATH}/${roomId}`);
  const snapshot = await roomRef.once('value');
  if (!snapshot.exists()) {
    setOnlineStatus("Room not found.");
    return;
  }

  const room = snapshot.val();
  if (room.hostId !== localClientId && room.guestId && room.guestId !== localClientId) {
    setOnlineStatus("Room is full.");
    return;
  }

  if (room.hostId !== localClientId) {
    await roomRef.update({
      guestId: localClientId,
      updatedAt: Date.now()
    });
    onlinePlayerNumber = 2;
  } else {
    onlinePlayerNumber = 1;
  }

  subscribeToRoom(roomId);
  onlineShareCode.textContent = `Joined room: ${roomId}`;
  if (room.state) applyOnlineState(room.state);
  setOnlineStatus(`Connected to room ${roomId}.`);
}

async function leaveOnlineRoom(resetBoard = true) {
  if (!onlineReady || !onlineSession.roomId) return;
  const roomId = onlineSession.roomId;
  const roomRef = db.ref(`${ONLINE_DB_PATH}/${roomId}`);

  if (onlineSession.unsubscribe) {
    roomRef.off('value', onlineSession.unsubscribe);
    onlineSession.unsubscribe = null;
  }

  try {
    const snapshot = await roomRef.once('value');
    if (snapshot.exists()) {
      const room = snapshot.val();
      if (room.hostId === localClientId) {
        await roomRef.remove();
      } else if (room.guestId === localClientId) {
        await roomRef.update({
          guestId: null,
          updatedAt: Date.now()
        });
      }
    }
  } catch (error) {
    console.error("Leave room failed:", error);
  }

  onlineSession.roomId = null;
  onlinePlayerNumber = null;
  onlineShareCode.textContent = "";
  onlineSession.lastStateHash = "";
  setOnlineStatus("Online mode is off.");
  updatePlayerTurn();

  if (resetBoard) {
    hideEndPopup();
    createGrid();
    startTurnTimer();
  }
}

function setMode(nextMode, options = {}) {
  if (nextMode === "online" && !onlineReady) {
    setOnlineStatus("Online mode unavailable. Add Firebase config first.");
    return;
  }

  const previousMode = mode;
  mode = nextMode;
  const isCpu = mode === "cpu";
  const isOnline = mode === "online";

  pvpMode.classList.toggle('active', mode === "pvp");
  cpuMode.classList.toggle('active', isCpu);
  onlineMode.classList.toggle('active', isOnline);
  pvpSettings.classList.toggle('hidden', isCpu || isOnline);
  difficultyButtons.classList.toggle('hidden', !isCpu);
  onlineControls.classList.toggle('hidden', !isOnline);

  if (previousMode === "online" && mode !== "online" && onlineSession.roomId) {
    void leaveOnlineRoom(false);
  }

  if (!options.skipReset) {
    hideEndPopup();
    createGrid();
    startTurnTimer();
    if (isOnline && onlineSession.roomId) {
      void publishOnlineState();
    }
  } else {
    updatePlayerTurn();
  }
}

onlineReady = initializeOnlineBackend();
if (!onlineReady) {
  onlineMode.disabled = true;
  onlineMode.classList.add('opacity-50', 'cursor-not-allowed');
  setOnlineStatus("Online unavailable. Set window.SQUARE_GAME_FIREBASE_CONFIG.");
}

[difficultyEasy, difficultyMedium, difficultyHard].forEach(btn => {
  btn.addEventListener('click', () => {
    difficulty = btn.dataset.value;
    [difficultyEasy, difficultyMedium, difficultyHard].forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

resetButton.addEventListener('click', () => {
  hideEndPopup();
  createGrid();
  startTurnTimer();
  if (mode === "online" && onlineSession.roomId) {
    void publishOnlineState();
  }
});

pvpMode.addEventListener('click', () => setMode("pvp"));
cpuMode.addEventListener('click', () => setMode("cpu"));
onlineMode.addEventListener('click', () => setMode("online"));
createRoomButton.addEventListener('click', () => { void createOnlineRoom(); });
joinRoomButton.addEventListener('click', () => { void joinOnlineRoom(); });
leaveRoomButton.addEventListener('click', () => { void leaveOnlineRoom(true); });
roomCodeInput.addEventListener('input', () => {
  roomCodeInput.value = roomCodeInput.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
});
roomCodeInput.addEventListener('keydown', event => {
  if (event.key === 'Enter') {
    void joinOnlineRoom();
  }
});

let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (gridContainer.childElementCount > 0) {
      createGrid({ preserveState: true });
    }
  }, 120);
});

setMode("pvp");
</script>
<script>
// Popup "Play Again" button listener
const popupButton = document.getElementById('popupButton');
popupButton.addEventListener('click', () => {
  hideEndPopup();
  createGrid();
  startTurnTimer();
  if (mode === "online") {
    void publishOnlineState();
  }
});
</script>
</body>
</html>
